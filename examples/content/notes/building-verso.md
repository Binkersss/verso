---
title: "Building Verso: A Static Site Generator and Server in Go (And How You're Seeing This Right Now)"
date: December 15th, 2025 
author: Nathaniel Chappelle
---

I knew I wanted a portfolio that would make my skills shine, but I am not the greatest front end dev. Therefore I decided to build a backend tool that would parse, build, and serve my portfolio (almost like a mini frontend framework).

### The Problem
- Wanted a minimal, text-focused portfolio
- Didn't want to deal with heavy JS frameworks
- Needed something that felt like a SPA but was actually static
- Wanted full control over the build process. 

Ok cool, looking at that you might suggest something like Astro or a similar content based JS library. That was my first direction but I felt like I was compromising. I knew I could make something really good from scratch and also get the added benefit on really understanding the framework I'm using.

So, let's start thinking about the Architecure.

### Core Components

1. **The Parser** (`pkg/parser/`)

I knew I wanted to use Markdown for my content. It is extensible, simple, and I use it for almost all forms of writing I may need to do. 

I decided on [Goldmark](https://github.com/yuin/goldmark) for Commonmark compliant parsing, with YAML frontmatters. This lets me convert `.md` to HTML with full metadata support. 

2. **The Builder** (`pkg/builder/`) 

The builder is the key to my vision. I wanted to have markdown (and other assets within the markdown) be the source of truth for site structure. I achieved this by having the builder walk the content directory recursively and generate a JSON manifest. 

That manifest lets me generate some simple JavaScript for client-side routing, as well as copying templates and static assets into the correct locations. 

At some point the builder won't even need to take in an HTML template or a `.css` file and will simply query a global database of themes for Verso. Of course, you'll still be able to do your own custom versions as well.

3. **The Client Generator** (`pkg/client/`)

The client generator is what I like to think sort of qualifies this as a JavaScript library. It embeds the content manifest straight into JS, handles SPA-style navigation, manages history so the URL and browser buttons work, and manages nice transitions between pages. 

Eventually the client generator will be more powerful, allowing the user to add to the framework with additional files in `static/`. However I really wanted to fully control all the JS in the library for now, as I don't want performance to be impacted by lazy development.

4. **The Dev Server** (`pkg/server/` + `pkg/watcher/`)

This is simple, but a requirement for easy development. File watching with fsnotify, automatic rebuilding on changes, and a simple go HTTP server to serve the static files after they are built. 

### The Build Process

Ok, so the architecture is actually fairly simple. Let's look at the build order:

1. Parse all markdown files from `content/`
2. Extract frontmatter and render markdown to HTML
3. Generate `content.json` manifest
4. Generate `app.js` with embedded routing
5. Copy templates and static assets to `dist/`

Turns out the build is also quite simple! You don't need 100's (or sometimes 1000's) of JS files for a build.

### The Client

The client is quite similar to a simple SPA. A single HTML shell is loaded on the first request. Javascript embeds the full content manifest so we don't need to fetch for that. Now the content is loaded, and is changed on every route change without a page reload. 

Eventually, with enough content, this might get pretty heavy and I'll have to come up with a new solution but it works great for now.

### Design Decisions

**Why Go?**

My biggest reason for choosing Go is the great templating and HTTP server, both of which are found in the stdlib. Additionally, I love the modules system and how easy it is for me to get a new content repo up and running. I can use the module to run it as a Go project, or the CLI tool and deploy with just a single binary. 

**Why Embed the Manifest?**

Well, one less network request is always good. Additionally, it gives me instant navigation and super simple deployment. It's just static files, which means projects generated by Verso can live almost anywhere!

**Why generate the client JS?**

Verso was designed to be a no-code, no-config tool. Simply write your content then run the command. By generating the client JS I am sacrificing a lot of flexibility for a lot of approachability. If someone seriously wants a feature, GitHub issues exist and I'm sure I can quickly implement a change (or they could submit a PR).

Additionally, this means that all projects built with Verso have the opportunity to gain new features with just a version bump. In the future this might not be that important, but in development I don't want to specifically update every Verso project I have to match a cool new feature I developed in some client-side JS.

### Using Verso

**Installation**:

```bash
go get github.com/Binkersss/verso
```

**Create Your Project Structure**:

```
my-site/
├── content/
│   ├── about.md
│   ├── projects.md
│   └── blog/
│       └── post-1.md
├── templates/
│   └── index.html
├── static/
│   ├── style.css
│   └── favicon.ico
└── main.go
```

**Create `main.go`**:

```go
package main

import (
    "log"
    "github.com/Binkersss/verso"
)

func main() {
    site := verso.New(verso.Config{
        ContentDir:   "content",
        TemplateDir:  "templates",
        StaticDir:    "static",
        OutputDir:    "dist",
    })
    
    if err := site.Serve(":3000"); err != nil {
        log.Fatal(err)
    }
}
```

**Create Your Template**:

**templates/index.html**:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Site</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">MY SITE</div>
            <nav id="nav"></nav>
        </aside>
        <main id="content"></main>
    </div>
    <script src="/app.js"></script>
</body>
</html>
```

**Write Content**:

**content/about.md**:
```markdown
---
title: About Me
date: 2024-12-13
---

# About Me

I build things with Go.
```

**Run**:

```bash
go run main.go
```
**Viewing**:
Visit `http://localhost:3000` to view your site!

In the near future you will just choose a theme and not have to give an HTML template or `.css` file, but for now any non-technical user could just copy paste and get it up and running. If you're wanting to make aesthetic changes, just ask Claude to update your HTML or `.css` to match what you're looking for.

### What's Next?

- Mobile friendly layout
- Prettier code blocks
- Blog Post Index Generation
- RSS Feed Support
- Theme Selection
- Image Optimization
- CMS style app build on top of Verso

### Meta: This Site

This very page you're reading is built with Verso. The entire site is 25 lines of Go code, some markdown files, and minimal CSS. No npm, no webpack, no framework bloat.

### Bonus Feature of Verso

Embed all your fancy HTML5 with Verso, building rich sites if you wish!

<canvas id="particles-canvas" style="display: block; width: 100%; height: 400px; background: #0a0e27;"></canvas>
