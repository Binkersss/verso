// pkg/client/generator.go
package client

import (
	"bytes"
	"encoding/json"
	"fmt"
	"text/template"
)

// Config controls client-side behavior
type Config struct {
	DefaultRoute       string // Route to load on initial visit (default: first page)
	EnableTransitions  bool   // Enable fade transitions between pages
	TransitionDuration int    // Transition duration in milliseconds (default: 150)
	NavSelector        string // CSS selector for nav container (default: "#nav")
	ContentSelector    string // CSS selector for content container (default: "#content")
}

// ContentManifest represents the structure of content.json
type ContentManifest struct {
	Pages map[string]Page `json:"pages"`
}

type Page struct {
	Route    string                 `json:"route"`
	Content  string                 `json:"content"`
	Metadata map[string]interface{} `json:"metadata"`
}

// DefaultConfig returns sensible defaults
func DefaultConfig() Config {
	return Config{
		DefaultRoute:       "",
		EnableTransitions:  true,
		TransitionDuration: 150,
		NavSelector:        "#nav",
		ContentSelector:    "#content",
	}
}

// Generate creates the client-side JavaScript code
func Generate(manifest ContentManifest, config Config) (string, error) {
	// Serialize manifest to JSON for embedding
	manifestJSON, err := json.Marshal(manifest)
	if err != nil {
		return "", fmt.Errorf("failed to marshal manifest: %w", err)
	}

	// Set default route if not specified
	defaultRoute := config.DefaultRoute
	if defaultRoute == "" && len(manifest.Pages) > 0 {
		// Pick first page alphabetically as default
		for route := range manifest.Pages {
			if defaultRoute == "" || route < defaultRoute {
				defaultRoute = route
			}
		}
	}

	// Template data
	data := struct {
		ManifestJSON       string
		DefaultRoute       string
		EnableTransitions  bool
		TransitionDuration int
		NavSelector        string
		ContentSelector    string
	}{
		ManifestJSON:       string(manifestJSON),
		DefaultRoute:       defaultRoute,
		EnableTransitions:  config.EnableTransitions,
		TransitionDuration: config.TransitionDuration,
		NavSelector:        config.NavSelector,
		ContentSelector:    config.ContentSelector,
	}

	// Generate JavaScript from template
	tmpl, err := template.New("client").Parse(clientTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// clientTemplate is the JavaScript template with routing logic
const clientTemplate = `// Generated by verso - do not edit manually
(function() {
    'use strict';

    // Embedded content manifest
    const MANIFEST = {{.ManifestJSON}};
    const DEFAULT_ROUTE = '{{.DefaultRoute}}';
    const ENABLE_TRANSITIONS = {{.EnableTransitions}};
    const TRANSITION_DURATION = {{.TransitionDuration}};
    const NAV_SELECTOR = '{{.NavSelector}}';
    const CONTENT_SELECTOR = '{{.ContentSelector}}';

    let currentRoute = null;

    // Initialize the app
    function init() {
        const nav = document.querySelector(NAV_SELECTOR);
        const content = document.querySelector(CONTENT_SELECTOR);

        if (!nav || !content) {
            console.error('verso: Required elements not found. Make sure your template has elements matching:', NAV_SELECTOR, CONTENT_SELECTOR);
            return;
        }

        renderNav(nav);
        
        // Get initial route from URL or use default
        const path = window.location.pathname.slice(1) || DEFAULT_ROUTE;
        navigateTo(path, false);

        // Handle browser back/forward
        window.addEventListener('popstate', function() {
            const path = window.location.pathname.slice(1) || DEFAULT_ROUTE;
            navigateTo(path, false);
        });

        // Intercept link clicks for SPA navigation
        document.addEventListener('click', function(e) {
            const link = e.target.closest('a');
            if (!link) return;

            // Only handle internal links
            const href = link.getAttribute('href');
            if (!href || href.startsWith('http') || href.startsWith('//') || href.startsWith('#')) {
                return;
            }

            e.preventDefault();
            const route = href.replace(/^\//, '');
            navigateTo(route);
        });
    }

    // Render navigation menu
    function renderNav(nav) {
        nav.innerHTML = '';
        
        // Sort routes alphabetically
        const routes = Object.keys(MANIFEST.pages)
            .filter(function(route) {
                return !route.includes('/');
            })
            .sort();
        
        routes.forEach(function(route) {
            const page = MANIFEST.pages[route];
            const item = document.createElement('div');
            item.className = 'nav-item';
            
            // Use title from metadata if available, otherwise use route
            const title = (page.metadata && page.metadata.title) || route;
            item.textContent = title;
            
            item.addEventListener('click', function() {
                navigateTo(route);
            });
            
            nav.appendChild(item);
        });
    }

    // Navigate to a route
    function navigateTo(route, pushState) {
        if (pushState === undefined) pushState = true;

        const page = MANIFEST.pages[route];
        if (!page) {
            console.error('verso: Page not found:', route);
            return;
        }

        // Don't re-render if already on this route
        if (currentRoute === route) return;
        
        currentRoute = route;
        const content = document.querySelector(CONTENT_SELECTOR);

        function updateContent() {
            content.innerHTML = page.content;
            
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(function(item) {
                const itemTitle = (page.metadata && page.metadata.title) || route;
                item.classList.toggle('active', item.textContent === itemTitle);
            });

            // Update document title if page has title metadata
            if (page.metadata && page.metadata.title) {
                document.title = page.metadata.title;
            }

            // Update URL
            if (pushState) {
                window.history.pushState({}, '', '/' + route);
            }

            // Scroll to top
            window.scrollTo(0, 0);

            // Remove fade class after content is updated
            if (ENABLE_TRANSITIONS) {
                setTimeout(function() {
                    content.classList.remove('fade');
                }, 10);
            }
        }

        if (ENABLE_TRANSITIONS) {
            content.classList.add('fade');
            setTimeout(updateContent, TRANSITION_DURATION);
        } else {
            updateContent();
        }
    }

    // Start the app when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
`
